#include "i2c1_BSP.h"

#define PRESC_VALUE		0xBU
#define SCLDEL_VALUE	0x4U
#define SDADEL_VALUE	0x2U
#define SCLH_VALUE		0xFU
#define SCLL_VALUE		0x13U


ErrorCode_t initCTRL_I2C1(void)
{
	/***********SCL & SDA Pin SETUP ***********/

	//PB8 will be I2C SCL, PB9 will be I2C SDA, both need to be set to Alternate Function 6

	//Enable Port B clock
	SET_BIT(RCC->IOPENR, RCC_IOPENR_GPIOBEN);
	//Set to alternate Function mode
	CLEAR_BIT(GPIOB->MODER, GPIO_MODER_MODE9 | GPIO_MODER_MODE8);
	SET_BIT(GPIOB->MODER, GPIO_MODER_MODE9_1 | GPIO_MODER_MODE8_1);
	//Set to open drain output
	SET_BIT(GPIOB->OTYPER, GPIO_OTYPER_OT9 | GPIO_OTYPER_OT8);
	//Set output speed register to very high speed
	SET_BIT(GPIOB->OSPEEDR, GPIO_OSPEEDR_OSPEED9 | GPIO_OSPEEDR_OSPEED8);
	//Turn off pull up resistor (they are too weak to be used for I2C signals)
	CLEAR_BIT(GPIOB->PUPDR, GPIO_PUPDR_PUPD9 | GPIO_PUPDR_PUPD8);
	//Set to alternate function 6
	CLEAR_BIT(GPIOB->AFR[1], GPIO_AFRH_AFSEL9 | GPIO_AFRH_AFSEL8);
	SET_BIT(GPIOB->AFR[1], GPIO_AFRH_AFSEL8_2 | GPIO_AFRH_AFSEL8_1);
	SET_BIT(GPIOB->AFR[1], GPIO_AFRH_AFSEL9_2 | GPIO_AFRH_AFSEL9_1);

	/**********************I2C SETUP******************************/

	//Enable I2C clock
	SET_BIT(RCC->APBENR1, RCC_APBENR1_I2C1EN);

	//Configure analog/digital noise filters by turning analog filter on and digital one off
	CLEAR_BIT(I2C1->CR1, I2C_CR1_ANFOFF);
	CLEAR_BIT(I2C1->CR1, I2C_CR1_DNF);

	//Configure the timing register according to 100kHz specifications from  table on page 710
	SET_BIT(I2C1->TIMINGR, PRESC_VALUE << I2C_TIMINGR_PRESC_Pos);//timing prescaler
	SET_BIT(I2C1->TIMINGR, SCLDEL_VALUE << I2C_TIMINGR_SCLDEL_Pos);//delay setup time
	SET_BIT(I2C1->TIMINGR, SDADEL_VALUE << I2C_TIMINGR_SDADEL_Pos);//delay hold time
	SET_BIT(I2C1->TIMINGR, SCLH_VALUE << I2C_TIMINGR_SCLH_Pos);///scl high period
	SET_BIT(I2C1->TIMINGR, SCLL_VALUE << I2C_TIMINGR_SCLL_Pos);///scl low period

	//Configure the CR2 register
	CLEAR_BIT(I2C1->CR2,I2C_CR2_ADD10);//addressing mode to 7 bits

	//Enable PE BIT
	SET_BIT(I2C1->CR1, I2C_CR1_PE);

	return E_OK;
}

ErrorCode_t transmitCTRL_I2C1(uint8_t address, uint8_t *transmitBuffer, uint8_t size)
{
	//Check for NULL Pointer
	if(transmitBuffer == 0)
		return E_INVALID_ARGUMENT;

    // 1. Wait for Bus to be Idle
    while(I2C1->ISR & I2C_ISR_BUSY);

    // 2. Clear the CR2 register
    I2C1->CR2 = 0;

    // 3. Configure CR2 for the packet (Write Direction is 0)
    uint32_t tmpreg = 0;
    // CRITICAL: Shift Address Left by 1
    tmpreg |= ((address << 1) & I2C_CR2_SADD);
    tmpreg |= ((size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES);
    tmpreg |= I2C_CR2_AUTOEND;
    tmpreg |= I2C_CR2_START;

    // 4. Write to CR2 and Initiate Transfer
    I2C1->CR2 = tmpreg;

    // 5. Transmit Loop
    for(int i = 0; i < size; i++)
    {
        // Wait for TXIS (Transmit Interrupt Status) and check for errors
        while( !(I2C1->ISR & I2C_ISR_TXIS) )
        {
            // Check for NACK (Address or Data NACK'd)
            if(I2C1->ISR & I2C_ISR_NACKF)
            {
            	// NACK Received (Peripheral failed to respond)
                SET_BIT(I2C1->ICR, I2C_ICR_NACKCF);
                return E_I2C_ACK_FAILED;
            }
        }

        // Write the current byte from the buffer and advance the pointer
        I2C1->TXDR = *transmitBuffer++;
    }

    // 6. Wait for STOP flag (generated by AUTOEND)
    while(!(I2C1->ISR & I2C_ISR_STOPF));

    // 7. Clear STOP flag
    SET_BIT(I2C1->ICR, I2C_ICR_STOPCF);

    return E_OK;
}


ErrorCode_t receiveCTRL_I2C1(uint8_t address, uint8_t *readBuffer, uint8_t size)
{
	//Check for NULL Pointer
	if(readBuffer == 0)
		return E_INVALID_ARGUMENT;

	 // 1. Ensure the bus is ready (not busy)
	 while(I2C1->ISR & I2C_ISR_BUSY)
		 ;

	 // 2. Clear the CR2 register
	 I2C1->CR2 &= ~((uint32_t)(I2C_CR2_SADD  |
	    						I2C_CR2_NBYTES  |
								I2C_CR2_RELOAD  |
								I2C_CR2_AUTOEND |
								I2C_CR2_RD_WRN  |
								I2C_CR2_START   |
								I2C_CR2_STOP));

	 // 3. Configure CR2 for this specific packet
	 // Set Address (Shifted), Set NBYTES, Set Read Direction (1)
	 uint32_t tmpreg = 0;
	 tmpreg |= ((address << 1) & I2C_CR2_SADD);
	 tmpreg |= ((size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES);
	 tmpreg |= I2C_CR2_RD_WRN;

	 // Optional: Set AUTOEND.
	 // If set, the hardware automatically generates a STOP after 'size' bytes are sent.
	 // If you don't set this, you must manually generate STOP later.
	 tmpreg |= I2C_CR2_AUTOEND;

	 // 4. Write to CR2 and Generate START
	 // The hardware will now automatically send: [START] -> [ADDRESS] -> [Wait for ACK]
	 tmpreg |= I2C_CR2_START;
	 I2C1->CR2 = tmpreg;

	 // 5. Loop to receive data
	 for(int i = 0; i < size; i++){
		 // Wait for RXNE and check for errors
		 while(!(I2C1->ISR & I2C_ISR_RXNE)){
			 if(I2C1->ISR & I2C_ISR_NACKF){

				 // NACK Received (Peripheral failed to respond)
	    	     SET_BIT(I2C1->ICR, I2C_ICR_NACKCF);
	    	     return E_I2C_ACK_FAILED; // Abort receive
	    	 }
	    }

	    // Read data from RXDR and store in buffer, then advance pointer
	    *readBuffer++ = (uint8_t) (I2C1->RXDR);
	 }
	 // 6. Wait for STOP flag (because we used AUTOEND)
	 while(!(I2C1->ISR & I2C_ISR_STOPF));

	 // 7. Clear the STOP flag
	 SET_BIT(I2C1->ICR, I2C_ICR_STOPCF);

	 return E_OK;
}

